% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ssq.R
\name{ssq}
\alias{ssq}
\title{Single-Server Queue Simulation}
\usage{
ssq(
  maxArrivals = Inf,
  seed = NA,
  interarrivalFcn = NULL,
  serviceFcn = NULL,
  interarrivalType = "M",
  serviceType = "M",
  maxTime = Inf,
  maxDepartures = Inf,
  maxInSystem = Inf,
  maxEventsPerSkyline = 15,
  saveAllStats = FALSE,
  saveInterarrivalTimes = FALSE,
  saveServiceTimes = FALSE,
  saveWaitTimes = FALSE,
  saveSojournTimes = FALSE,
  saveNumInQueue = FALSE,
  saveNumInSystem = FALSE,
  saveServerStatus = FALSE,
  showOutput = TRUE,
  animate = FALSE,
  show = NULL,
  showQueue = TRUE,
  showSkyline = TRUE,
  showSkylineInSystem = TRUE,
  showSkylineInQueue = TRUE,
  showSkylineInServer = TRUE,
  showTitles = TRUE,
  showProgress = TRUE,
  plotQueueFcn = defaultPlotSSQ,
  plotSkylineFcn = defaultPlotSkyline,
  jobImage = NA,
  plotDelay = NA,
  respectLayout = FALSE
)
}
\arguments{
\item{maxArrivals}{maximum number of customer arrivals allowed to enter the system}

\item{seed}{initial seed to the random number generator (NA uses current state of
random number generator; NULL seeds using system clock)}

\item{interarrivalFcn}{Function for generating interarrival times for queue simulation.
Default value (\code{NA}) will result in use of default interarrrival
function based on \code{interarrivalType}.  See examples.}

\item{serviceFcn}{Function for generating service times for queue simulation.
Default value (\code{NA}) will result in use of default service function
based on \code{serviceType}.  See examples.}

\item{interarrivalType}{string representation of desired interarrival process
(default is "M": exponential with rate 1).}

\item{serviceType}{string representation of desired service process
(default is "M": exponential with rate 10/9).}

\item{maxTime}{maximum time to simulate}

\item{maxDepartures}{maximum number of customer departures to process}

\item{maxInSystem}{maximum number of customers that the system can hold (server(s) plus queue).
Infinite by default.}

\item{maxEventsPerSkyline}{maximum number of events viewable at a time in the skyline plot.
A large value for this parameter may result in plotting delays.
This parameter does not impact the final plotting, which will show all
end-of-simulation results.}

\item{saveAllStats}{if TRUE, returns all vectors of statistics (see below)
collected by the simulation}

\item{saveInterarrivalTimes}{if TRUE, returns a vector of all interarrival times generated}

\item{saveServiceTimes}{if TRUE, returns a vector of all service times generated}

\item{saveWaitTimes}{if TRUE, returns a vector of all wait times (in the queue) generated}

\item{saveSojournTimes}{if TRUE, returns a vector of all sojourn (time in the system)
times generated}

\item{saveNumInQueue}{if TRUE, returns a vector of times and a vector of counts for whenever
the number in the queue changes}

\item{saveNumInSystem}{if TRUE, returns a vector of times and a vector of counts for whenever
the number in the system changes}

\item{saveServerStatus}{if TRUE, returns a vector of times and a vector of
server status (0:idle, 1:busy) for whenever the status changes}

\item{showOutput}{if TRUE, displays summary statistics upon completion}

\item{animate}{If FALSE, no animation plots will be shown.}

\item{show}{shorthand specifier for showQueue and showSkyline. 1 for queue, 2 for skyline,
3 for both (chmod component style)}

\item{showQueue}{if TRUE, displays a visualization of the queue}

\item{showSkyline}{Shorthand for specifying showSkyline... parameters using chmod-like
octal component specification: use 1, 2, 4 for system, queue, and server
respectively, summing to indicate desired combination (e.g., 7 for all).}

\item{showSkylineInSystem}{if TRUE, the skyline will track the number of elements in the system.}

\item{showSkylineInQueue}{if TRUE, the skyline will track the number of elements in the queue.}

\item{showSkylineInServer}{if TRUE, the skyline will track the number of elements in the server.}

\item{showTitles}{if TRUE, titles will be shown on plots}

\item{showProgress}{if TRUE, displays a progress bar on screen during execution}

\item{plotQueueFcn}{Plotting function to display Queue visualization.
By default, this is provided by \code{defaultPlotSSQ}. Please refer to
that associated help for more details about required arguments.}

\item{plotSkylineFcn}{Plotting function to display Skyline visualization.
By default, this is provided by \code{defaultPlotSkyline}.  Please refer
to thaat associated help for more details about required arguments.}

\item{jobImage}{a vector of URLs/local addresses of images to use as jobs. Requires
package 'Magick'.}

\item{plotDelay}{a positive numeric value indicating seconds between state plottings.
A value of -1 enters 'interactive' mode, where the state will pause
for user input at each step.  A value of 0 will display only the final
end-of-simulation plot.}

\item{respectLayout}{If true, plot layout (i.e. par, device, etc.) settings will be respected
Not recommended except for specialized/advanced use.}
}
\value{
The function returns a list containing:
\itemize{
\item the number of arrivals to the system (\code{customerArrivals}),
\item the number of customers processed (\code{customerDepartures}),
\item the ending time of the simulation (\code{simulationEndTime}),
\item average wait time in the queue (\code{avgWait}),
\item average time in the system (\code{avgSojourn}),
\item average number in the system (\code{avgNumInSystem}),
\item average number in the queue (\code{avgNumInQueue}), and
\item server utilization (\code{utilization}).
}
of the queue as computed by the simulation.
When requested via the ``save...'' parameters, the list may also contain:
\itemize{
\item a vector of interarrival times (\code{interarrivalTimes}),
\item a vector of wait times (\code{waitTimes}),
\item a vector of service times (\code{serviceTimes}),
\item a vector of sojourn times (\code{sojournTimes}),
\item two vectors (time and count) noting changes to number in the system
(\code{numInSystemT}, \code{numInSystemN}),
\item two vectors (time and count) noting changes to number in the queue
(\code{numInQueueT}, \code{numInQueueN}), and
\item two vectors (time and status) noting changes to server status
(\code{serverStatusT}, \code{serverStatusN}).
}
}
\description{
A next-event simulation of a single-server queue, with
extensible arrival and service processes.
}
\details{
Implements a next-event implementation of a single-server queue simulation.

The \code{seed} parameter can take one of three valid
argument types:
\itemize{
\item \code{NA} (default), which will use the current state of the random
number generator without explicitly setting a new seed (see examples);
\item a positive integer, which will be used as the initial seed passed in
an explicit call to \code{\link{set.seed}}; or
\item \code{NULL}, which will be passed in an explicit call to to
\code{\link{set.seed}}, thereby setting the initial seed using the
system clock.
}
}
\examples{
 # process 2000 arrivals, R-provided seed (via NULL seed)
 ssq(2000, NULL)

 ssq(maxArrivals = 2000, seed = 54321)
 ssq(maxDepartures = 2000, seed = 54321)
 ssq(maxTime = 1000, seed = 54321)

 ############################################################################
 # example to show use of seed = NA (default) to rely on current state of generator
 output1 <- ssq(2000, 8675309, showOutput = FALSE, saveAllStats = TRUE)
 output2 <- ssq(3000,          showOutput = FALSE, saveAllStats = TRUE)
 set.seed(8675309)
 output3 <- ssq(2000,          showOutput = FALSE, saveAllStats = TRUE)
 output4 <- ssq(3000,          showOutput = FALSE, saveAllStats = TRUE)
 sum(output1$sojournTimes != output3$sojournTimes) # should be zero
 sum(output2$sojournTimes != output4$sojournTimes) # should be zero

 myArrFcn <- function() { vexp(1, rate = 1/4, stream = 1)  }  # mean is 4
 mySvcFcn <- function() { vgamma(1, shape = 1, rate = 0.3) }  # mean is 3.3

 output <- ssq(maxArrivals = 1000, interarrivalFcn = myArrFcn, serviceFcn = mySvcFcn,
              saveAllStats = TRUE)
 mean(output$interarrivalTimes)
 mean(output$serviceTimes)
 meanTPS(output$numInQueueT, output$numInQueueN) # compute time-averaged num in queue
 meanTPS(output$serverStatusT, output$serverStatusN) # compute server utilization

 ############################################################################
 # example to show use of (simple) trace data for arrivals and service times;
 # ssq() will need one more interarrival (arrival) time than jobs processed
 #
 initTimes <- function() {
     arrivalTimes      <<- c(15, 47, 71, 111, 123, 152, 232, 245, 99999)
     interarrivalTimes <<- c(arrivalTimes[1], diff(arrivalTimes))
     serviceTimes      <<- c(43, 36, 34, 30, 38, 30, 31, 29)
 }

 getInterarr <- function() {
     nextInterarr <- interarrivalTimes[1]
     interarrivalTimes <<- interarrivalTimes[-1] # remove 1st element globally
     return(nextInterarr)
 }

 getService <- function() {
     nextService <- serviceTimes[1]
     serviceTimes <<- serviceTimes[-1]  # remove 1st element globally
     return(nextService)
 }

 initTimes()
 numJobs <- length(serviceTimes)
 output <- ssq(maxArrivals = numJobs, interarrivalFcn = getInterarr,
               serviceFcn = getService, saveAllStats = TRUE)
 mean(output$interarrivalTimes)
 mean(output$serviceTimes)


 ############################################################################
 # example to show use of (simple) trace data for arrivals and service times,
 # allowing for reuse (recycling) of trace data times

 initArrivalTimes <- function() {
   arrivalTimes      <<- c(15, 47, 71, 111, 123, 152, 232, 245)
   interarrivalTimes <<- c(arrivalTimes[1], diff(arrivalTimes))
 }

 initServiceTimes <- function() {
     serviceTimes      <<- c(43, 36, 34, 30, 38, 30, 31, 29)
 }

 getInterarr <- function() {
     if (length(interarrivalTimes) == 0)  initArrivalTimes()

     nextInterarr <- interarrivalTimes[1]
     interarrivalTimes <<- interarrivalTimes[-1] # remove 1st element globally
     return(nextInterarr)
 }

 getService <- function() {
     if (length(serviceTimes) == 0)  initServiceTimes()

     nextService <- serviceTimes[1]
     serviceTimes <<- serviceTimes[-1]  # remove 1st element globally
     return(nextService)
 }

 initArrivalTimes()
 initServiceTimes()
 output <- ssq(maxArrivals = 100, interarrivalFcn = getInterarr,
               serviceFcn = getService, saveAllStats = TRUE)
 mean(output$interarrivalTimes)
 mean(output$serviceTimes)

 ############################################################################
 # Testing with visualization

 # Visualizing ssq with a set seed, infinite queue capacity, 20 arrivals,
 # interactive mode (default), showing skyline for all 3 attributes (default)
 ssq(seed = 1234, maxArrivals = 20, animate = TRUE)

 # Same as above, but jump to final queue visualization
 ssq(seed = 1234, maxArrivals = 20, animate = TRUE, plotDelay = 0)

 # Perform simulation again with finite queue of low capacity. Note same
 # variable generation but different outcomes due to rejection pathway
 ssq(seed = 1234, maxArrivals = 25, animate = TRUE, maxInSystem = 5)

 ############################################################################
 # Testing with built-in and custom arrival/service processes

 # Defining custom generation function as parameterization of v*
 iarFcn <- function(num_in_sys, as_list)
    vexp(1, rate = 0.3, stream = 1, asList = as_list)
 svcFcn <- function(num_in_sys, as_list)
    vbinom(1, size = 5, prob = 0.1, stream = 2, asList = as_list)
 ssq(
    seed            = 1234,
    maxDepartures   = 10,
    interarrivalFcn = iarFcn,
    serviceFcn      = svcFcn
 )

 # Using default distributions to make a default M/G/1 Queue
 ssq(seed = 1234, maxDepartures = 10, interarrivalType = "M", serviceType = "G")

 # Developing a custom distribution function that uses number in the system
 iarFcn <- function(num_in_sys, as_list) {
    u <- vunif(1, stream = 1)
    if (as_list) {
      return(list(
          "u"        = u,
          "x"        = qexp(u, 1) * (num_in_sys + 1) / 5,
          "quantile" = function(i) qexp(i, 1) * (num_in_sys) / 5,
          "text"     = "Special Function"
      ))
    } else {
      return(u)
    }
 }

 ssq(seed = 1234, maxDepartures = 10, interarrivalFcn = iarFcn)

}
\seealso{
\code{\link{rstream}}, \code{\link{set.seed}},
\code{\link[=runif]{stats::runif}}
}
\author{
Barry Lawson (\email{blawson@richmond.edu}), \cr
Larry Leemis (\email{leemis@math.wm.edu}), \cr
Vadim Kudlay (\email{vadim.kudlay@richmond.edu})
}
\concept{queueing}
\keyword{utilities}
